{"zed":"conversation","version":"0.1.0","text":"jest.mock('@mazeapp/shared-hooks', () => ({\n  useCurrentUser: jest.fn().mockReturnValue({ id: '123', token: 'token', hasFigmaAccessToken: true }),\n  useCurrentTeam: jest.fn().mockReturnValue({ id: '456' }),\n  useTeamFeatureFlag: jest.fn().mockReturnValue({\n    hasTeamFlag(flag: string) {\n      if (flag === FEATURE_FLAG_FIGMA_LIVE_EMBED_OPTION) return [true, jest.fn()];\n      if (flag === FEATURE_FLAG_FIGMA_LIVE_EMBED_BY_DEFAULT) return [false, jest.fn()];\n      return [true, jest.fn()];\n    },\n  }),\n}));\nTo mock\nI have that on top of my test file, and it does work with a bunch of tests. I want to create a new test on that file but changing the mock value ONLY for that single test\nTo change the mock value for a single test while keeping the other mocks intact, you can create a local mock implementation using `jest.mock.mockImplementationOnce()` inside your test. This will override the mock behavior for that specific test case.\n\nHere's an example:\n\n```javascript\nimport { useCurrentUser } from '@mazeapp/shared-hooks';\n\njest.mock('@mazeapp/shared-hooks', () => ({\n  useCurrentUser: jest.fn().mockReturnValue({ id: '123', token: 'token', hasFigmaAccessToken: true }),\n  useCurrentTeam: jest.fn().mockReturnValue({ id: '456' }),\n  useTeamFeatureFlag: jest.fn().mockReturnValue({\n    hasTeamFlag(flag: string) {\n      if (flag === FEATURE_FLAG_FIGMA_LIVE_EMBED_OPTION) return [true, jest.fn()];\n      if (flag === FEATURE_FLAG_FIGMA_LIVE_EMBED_BY_DEFAULT) return [false, jest.fn()];\n      return [true, jest.fn()];\n    },\n  }),\n}));\n\ntest('your test case', () => {\n  useCurrentUser.mockImplementationOnce(() => ({ id: '789', token: 'newToken', hasFigmaAccessToken: false }));\n\n  // your test code here\n\n  // Make your assertions\n});\n```\n\nIn the example above, `useCurrentUser.mockImplementationOnce()` provides a new implementation only for the specific test. The subsequent calls to `useCurrentUser` will continue to use the original mock implementation.\n\nThis way, you can modify the behavior of the mock for a single test case while keeping the existing mock behavior for other tests.\n","messages":[{"id":0,"start":0},{"id":11,"start":518},{"id":15,"start":689},{"id":16,"start":2097}],"message_metadata":{"8":{"role":"user","sent_at":"2023-07-04T13:22:30.594058+02:00","status":"Done"},"0":{"role":"user","sent_at":"2023-07-04T12:56:17.393326+02:00","status":"Done"},"2":{"role":"user","sent_at":"2023-07-04T12:56:19.030246+02:00","status":"Done"},"10":{"role":"user","sent_at":"2023-07-04T13:22:38.163440+02:00","status":"Done"},"1":{"role":"user","sent_at":"2023-07-04T12:56:18.913068+02:00","status":"Done"},"4":{"role":"user","sent_at":"2023-07-04T12:56:39.706719+02:00","status":"Done"},"12":{"role":"user","sent_at":"2023-07-04T13:23:26.588372+02:00","status":"Done"},"3":{"role":"assistant","sent_at":"2023-07-04T12:56:39.706314+02:00","status":"Done"},"16":{"role":"user","sent_at":"2023-07-04T13:24:44.596002+02:00","status":"Done"},"5":{"role":"assistant","sent_at":"2023-07-04T13:02:27.261886+02:00","status":"Done"},"9":{"role":"assistant","sent_at":"2023-07-04T13:22:38.163041+02:00","status":"Done"},"7":{"role":"assistant","sent_at":"2023-07-04T13:22:30.593880+02:00","status":"Pending"},"11":{"role":"user","sent_at":"2023-07-04T13:23:26.451776+02:00","status":"Done"},"6":{"role":"user","sent_at":"2023-07-04T13:02:27.262038+02:00","status":"Done"},"13":{"role":"assistant","sent_at":"2023-07-04T13:23:55.228125+02:00","status":"Done"},"14":{"role":"user","sent_at":"2023-07-04T13:23:55.228428+02:00","status":"Done"},"15":{"role":"assistant","sent_at":"2023-07-04T13:24:44.595576+02:00","status":"Done"}},"summary":"jest.mock Mock Functions as Return Values","model":"gpt-3.5-turbo-0613"}